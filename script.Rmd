---
title: "R Notebook"
output: html_notebook
---


# Contexto dos dados
Os dados são sobre queimadas 
link: https://archive.ics.uci.edu/ml/datasets/Forest+Fires.

   1. X - x-axis spatial coordinate within the Montesinho park map: 1 to 9
   2. Y - y-axis spatial coordinate within the Montesinho park map: 2 to 9
   3. month - month of the year: "jan" to "dec" 
   4. day - day of the week: "mon" to "sun"
   5. FFMC - FFMC index from the FWI system: 18.7 to 96.20
   6. DMC - DMC index from the FWI system: 1.1 to 291.3 
   7. DC - DC index from the FWI system: 7.9 to 860.6 
   8. ISI - ISI index from the FWI system: 0.0 to 56.10
   9. temp - temperature in Celsius degrees: 2.2 to 33.30
   10. RH - relative humidity in %: 15.0 to 100
   11. wind - wind speed in km/h: 0.40 to 9.40 
   12. rain - outside rain in mm/m2 : 0.0 to 6.4 
   13. area - the burned area of the forest (in ha): 0.00 to 1090.84 
   (this output variable is very skewed towards 0.0, thus it may make
    sense to model with the logarithm transform). 

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(fields)
library(tidyverse)
library(broom)
library(corrplot)

dados <- read.csv("forestfires.csv")
dados$isBurned <- ifelse(dados$area == 0 , 0 , 1)
dados$lnArea <- log(dados$area + 1)

dados$damage_category <- ifelse(dados$area == 0, 'Sem dano', 
                                ifelse(dados$area <= 1, 'Baixo',
                                       ifelse(dados$area <= 25, 'Moderado', 
                                              ifelse(dados$area <= 100, 'Alto', 'Muito alto'))))
dados$month_c <- as.numeric(dados$month)
dados$day_c <- as.numeric(dados$day)

dados %>%
   mutate_at(scale, .vars = vars(-isBurned, -damage_category, -month, -day)) -> zDados




```


# Análise descritiva

O material [Applied Multivariate Analysis, Darren Homrighausen, PhD](https://darrenho.github.io/AMA/regression4example.pdf) utiliza um mecanismo para visualizar a média das áreas queimadas, conforme a localização X e Y no conjunto de dados.


```{r, echo=TRUE, include=TRUE}

x = dados$X
y = dados$Y
x.un = sort(unique(x))
y.un = sort(unique(y))
plot.resp = rep(0,length(x.un)*length(y.un))
sweep = 0
months = dados$month %>% unique()

for(i in x.un){
  for(j in y.un){
    sweep = sweep + 1
    plot.resp[sweep] = mean(dados$area[x == i & y == j])
  }
}
plot.resp.mat = matrix(plot.resp,nrow=length(x.un),ncol=length(y.un),byrow=T)
grid.list = list(x = x.un,y=y.un,z = plot.resp.mat)
image.plot(grid.list, main = "Média de área queimada")




```

# Análise exploratória

```{r}

dados %>%
   select(-isBurned, -damage_category, -month, -day) %>% 
   cor() -> cor_dados
corrplot(cor_dados, type = "upper", order = "hclust", 
         tl.col = "black", tl.srt = 45)


```


O interesse é modelar áreas que foram queimadas. Analisando o conjunto de dados, notamos que `r round(prop.table(table(dados$isBurned))[1]*100,2)`% é de área não queimada.

Sendo assim, iremos filtrar nosso conjunto de dados selecionando apenas os registros que a coluna **area > 0**.

Outra alternativa seria aplicar alguma transformação na variável resposta, como um log por exemplo. **ainda n coloquei este cenário (log de area) no código**

```{r echo=T, message=FALSE, warning=FALSE, prompt=T}

dados%>%
   filter(isBurned==1) -> burnedArea

tempdat <- dados

```

# Forward Regression

```{r echo=TRUE, include=T}

# minimal.model = lm(lnArea ~ 1, data = tempdat)
# forward.model = MASS::stepAIC(minimal.model,
#                                scope = list(upper = ~ X + Y + month + temp + RH  + rain + wind,  lower = ~1),
#                               direction="forward",trace = TRUE)  
# summary(forward.model)
# 
# forward.model2 = MASS::stepAIC(minimal.model,
#                                scope = list(upper = ~ temp + RH + wind + X + Y + DMC + month + FFMC + day + ISI + rain + DC,  lower = ~1),
#                               direction="forward",trace = TRUE)  
# 
# 


```


# Teste

```{r, echo=F, prompt=F}

rsquared <- data.frame(back = NA, forw = NA, step = NA)
cota <- 0.05617002
rsq <- NA

models1 <- list()
summaryModel1 <- list()

models2 <- list()
summaryModel2 <- list()

models3 <- list()
summaryModel3 <- list()

for(i in 1:1000000){
   set.seed(i)
   id <- sample(1:nrow(tempdat), size = trunc(runif(1,.7,1)*nrow(tempdat)),replace = F)
   sampDados <- dados[id,]   
   minimal.model = lm(lnArea ~ 1, data = sampDados)
   forward.model =  MASS::stepAIC(minimal.model,
                                scope = list(upper = ~ temp + RH + wind + X + Y + DMC + month + FFMC + day + ISI + rain + DC,
                                           lower = ~1),
                              direction="forward",trace = TRUE)
   full.model = lm(lnArea ~ temp + RH + wind + X + Y + DMC + month + FFMC + day + ISI + rain + DC, data = sampDados)
   backward.model = MASS::stepAIC(full.model, 
                                scope = list(upper = ~ temp + RH + wind + X + Y + DMC + month + FFMC + day + ISI + rain + DC,
                                             lower = ~1),
                               direction="backward",trace = TRUE)  
   initial.model = lm(lnArea ~ 1, data = sampDados)
   stepwise.model = MASS::stepAIC(initial.model, 
                                scope = list(upper = ~ temp + RH + wind + X + Y + DMC + month + FFMC + day + ISI + rain + DC,  
                                             lower = ~ 1),
                               direction="both",trace = TRUE) 
   
   model1 <- summary(backward.model)
   model2 <- summary(forward.model)
   model3 <- summary(stepwise.model)
   
   rsquared[i,1] <- model1$r.squared
   rsquared[i,2] <- model2$r.squared
   rsquared[i,3] <- model3$r.squared
   models1[[i]] <- backward.model
   models2[[i]] <- forward.model
   models3[[i]] <- stepwise.model
   summaryModel1[[i]] <- model1
   summaryModel2[[i]] <- model2
   summaryModel3[[i]] <- model3
}

par(mfrow=c(3,1))
plot(rsquared$back, t = "l", ylim = c(0,1))
plot(rsquared$forw, t = "l", ylim = c(0,1))
plot(rsquared$step, t = "l", ylim = c(0,1))


```



# Backward Regression


```{r echo=TRUE}

# full.model = lm(lnArea ~ X + Y + month + day + temp + RH + wind + rain, data = tempdat)
# backward.model = MASS::stepAIC(full.model, 
#                                 scope = list(upper = ~ X + Y + month + day + temp + RH + wind + rain,  lower = ~1),
#                                direction="backward",trace = TRUE)  
#   
# 
# summary(backward.model)
#   
# backward.model2 = MASS::stepAIC(full.model, 
#                                 scope = list(upper = ~ temp + RH + wind + X + Y + DMC + month + FFMC + day + ISI + rain + DC,  lower = ~1),
#                                direction="backward",trace = TRUE)  
#   
# 
# summary(backward.model2)
```

# Stepwise Regression


```{r echo=TRUE}

# initial.model = lm(lnArea ~ 1, data = tempdat)
# stepwise.model = MASS::stepAIC(initial.model, 
#                                 scope = list(upper = ~ X + Y + month + day + temp + RH + wind + rain,  lower = ~1),
#                                direction="both",trace = TRUE)  
# # tidy(stepwise.model)initial.model = lm(lnArea ~ 1, data = tempdat)
# stepwise.model2 = MASS::stepAIC(initial.model, 
#                                 scope = list(upper = ~  temp + RH + wind + X + Y + DMC + month + FFMC + day + ISI + rain + DC,  lower = ~1),
#                                direction="both",trace = TRUE)  
# summary(stepwise.model)
# summary(stepwise.model2)  

```